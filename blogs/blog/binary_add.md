---
title: 数据的表示和运算
date: 2022-07-05
categories:
 - 计算机组成原理
tags:
 - 可恶的408
cover: /images/covers/bw.jpg
---

搞得不是很清楚

<!-- more  -->

## 各种码

进制转换就比较简单

### BCD码

二进制表十进制，不一定是1248的权，有冗余

### 原码

最高位符号位，其他的就是十进制转二进制

### 补码

> 看了些补码的资料，了解了补数（两个数相加为一个常数，它们互补），一个n位二进制数$N$的二进制补数（这里资料是补码，但是正数的补码是一个负数感觉冲突了，用补数可能对我来说好理解一点）为$2^n-N$，这个数可以代表$-N$（补成0），也可以是$2^n-N$（补成$2^n$），取决于把它看作补码还是无符号数。二进制算术$Z=X-Y=X+(2^n-Y)=2^n+(X-Y)$，这个$2^n$作为不需要的进位舍弃。求补的运算非常简单$2^n-N=2^n-1-N+1=111...1-N+1=\bar{N}+1$也是就取反加1。假设N真值大于等于0则-N的二进制补码就是N的取反加1。

**对补码感兴趣是因为，减一个属等于加上这个数的补数（模上补数之和）,减法转换为对减数的补数的加法运算**

计算的话，如果需要$-N$，那就是加上$N$的补数，对$N$取反加一。也就是被减数加上减数的补数。

正数的补码就是原码，负数的补码是绝对值取反加一（也就是补数的二进制表示）。

::: danger
她太精妙了，我只能理解一点点。感觉困难可能是由于把$-$看成减号还是负号造成的。
:::

### 反码

整数原码不变，负数原码取反

### 移码

在真值上加了个偏置值，向x轴正向移动多少多少

## 定点数运算

### 移位

- **算术移位**

1. 对于正数，空位添0
2. 对于负数，原码添0，反码添1，补码左移添0，右移添1

- **逻辑移位**

左移右移都添0

- **循环移位**

移出的数又被移回来

1. 带进位，最低或最高位移出到进位，进位移入到最高或最低位
2. 不带进位，最高位移到进位和最低位或者最低位移到最高位和进位

### 补码加减

加法补码相加，减法被减数加减数的补数

**溢出判断**，只有在同号相加和异号相减时会产生溢出，单符号位，双符号位，进位判断

### 原码加减

1. 加法，符号同绝对值相加，符号不变，不同做减法，绝对值大减小，符号取大的
2. 减法，减数符号取反，按加法来

### 原码一位乘法

绝对值乘，符号位符号异或

乘数的每一位乘上被乘数，加到部分积种然后右移一位。

每一次都要右移o

### 补码一位乘法

booth乘法

> 补码一位乘法（Booth算法）搞了老半天才知道为什么要用$y_n-y_{n+1}$的结果作为加减被乘数的判断，$y_n$在超级聪明的化简后成为了一个带权展开的多项式，假装$Y$长成$[y]_补=Y=y_{n-1}y_{n-1}...y_{0}$，如果为整数真值按权展开为$\varSigma_{i=0}^{n-2}2^iy_i$，如果是补码负数就是负的取反加+1在即$-[1+\varSigma_{i=0}^{n-2}2^i(1-y_i)]$，然后就是对它累加展开化简，并利用符号位与$Y$正的情况合并，再对合并后的公式的累加展开化简,对中间项加自己减自己，每个中间项可以合并2，就与前一项可以提取“权”，最后得到$\Sigma_{i=0}^{n-1}2^i(-y_i+y_{i-1})$，大概是理解了吧，可能吧。

乘数末尾附加1位。最后一步不再右移了

### 原码除法

不恢复余数法也称加减交替法，减法使用补码，商符用异或

被除数和除数都是绝对值操作

先是被除数减去除数，如果余数为正则上1并且左移一位减去除数，余数为负则上0并且左移一位加上除数

如果最后一步（n+1）余数为负数，还需要加上除数。

### 补码除法

加减交替法，第一步根据被除数和除数的符号决定加法还是减法（同号减异号加），上商根据余数和除数符号决定（同号上1，异号上0）

### 类型转换

### 大端小端

### 对齐

## 浮点数

二进制的科学计数法

数符（S0正1负）+阶码（E移码）+尾数（M原码顶点小数）

### 规格化

- **左规**

最高位不为1，就一直左移左移左移，阶码-1-1-1，知道最高位为有效位，就像科学计数法写1-10（好像把）

- **右规**

有效位进位到小点前面，需要右规一次，阶码+1，但可能精度损失，就像科学家计数法11了


### IEEE754

单精度双精度

隐藏最高位1，阶码偏置值注意。

### 运算

1. 对阶，小向大，位数右移可能为产生误差
2. 尾数求和
3. 规格化，右规左规
4. 舍入，对阶和右规会进行右移，右移会产生精度问题，一般保留移除两位，0舍1入，入了可能又要右规又要舍入，恒指1，有失位，最低位置1，截断法，截断所需位数后面都不要
5. 溢出判断，尾数规格化和舍入阶码加加减减可能会产生溢出，正上溢，异常，负下溢，机器零。右规和舍入时阶码可能会加上去，判断阶码全为1是否正上溢。左规，阶码-1，判断是否全为0，是否下溢

阶码或尾数是补码双符号位，尾数符号位出现10，01，需要右规，出现00.0或11.1需要左规，归到00.1或11.0

### c语言

浮点数转换是的精度问题